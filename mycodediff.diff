diff --git a/.gitignore b/.gitignore
index 3e2c9de..8d6e9be 100644
--- a/.gitignore
+++ b/.gitignore
@@ -13,4 +13,4 @@ initcode.out
 kernel
 kernelmemfs
 mkfs
-.gdbinit
+.gdbinit
\ No newline at end of file
diff --git a/Makefile b/Makefile
index 09d790c..51d1082 100644
--- a/Makefile
+++ b/Makefile
@@ -181,6 +181,11 @@ UPROGS=\
 	_usertests\
 	_wc\
 	_zombie\
+	_lab2\
+	_lab2a\
+	_lab2b\
+	_lab2c\
+	_lab2_starvation\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
@@ -217,7 +222,7 @@ QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
 	then echo "-gdb tcp::$(GDBPORT)"; \
 	else echo "-s -p $(GDBPORT)"; fi)
 ifndef CPUS
-CPUS := 2
+CPUS := 1
 endif
 QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
 
diff --git a/defs.h b/defs.h
index 82fb982..923f382 100644
--- a/defs.h
+++ b/defs.h
@@ -119,6 +119,7 @@ void            sleep(void*, struct spinlock*);
 void            userinit(void);
 int             wait(void);
 void            wakeup(void*);
+int             set_prior(int);
 void            yield(void);
 
 // swtch.S
diff --git a/exec.c b/exec.c
index b40134f..ec7d707 100644
--- a/exec.c
+++ b/exec.c
@@ -93,6 +93,13 @@ exec(char *path, char **argv)
       last = s+1;
   safestrcpy(curproc->name, last, sizeof(curproc->name));
 
+  // Initialize process start time and burst time and burst ticks.
+  acquire(&tickslock);
+  curproc->t_start = ticks;
+  curproc->burst_tick = ticks;
+  release(&tickslock);
+  curproc->burst_time = 0;
+
   // Commit to the user image.
   oldpgdir = curproc->pgdir;
   curproc->pgdir = pgdir;
diff --git a/lab2.c b/lab2.c
new file mode 100644
index 0000000..ef5b9aa
--- /dev/null
+++ b/lab2.c
@@ -0,0 +1,8 @@
+#include "types.h"
+#include "user.h"
+int main (int argc, char **argv)
+{
+    int prir = set_prior(2);
+    printf(1, "PRIORITY: %d\n", prir);
+    exit();
+}
\ No newline at end of file
diff --git a/lab2_starvation.c b/lab2_starvation.c
new file mode 100644
index 0000000..1e9bc1b
--- /dev/null
+++ b/lab2_starvation.c
@@ -0,0 +1,11 @@
+#include "types.h"
+#include "user.h"
+int main (int argc, char **argv)
+{
+    int prir = set_prior(0);
+    printf(1, "PRIORITY: %d\n", prir);
+    for(;;){
+        asm("nop");
+    }
+    exit();
+}
\ No newline at end of file
diff --git a/lab2a.c b/lab2a.c
new file mode 100644
index 0000000..91302b3
--- /dev/null
+++ b/lab2a.c
@@ -0,0 +1,15 @@
+#include "types.h"
+#include "user.h"
+int main (int argc, char **argv)
+{
+    int prir = set_prior(10);
+    printf(1, "PRIORITY: %d\n", prir);
+    int i,k;
+    for(i = 0; i < 43000; i++){
+        asm("nop");
+        for(k = 0; k < 43000; k++){
+            asm("nop");
+        }
+    }
+    exit();
+}
\ No newline at end of file
diff --git a/lab2b.c b/lab2b.c
new file mode 100644
index 0000000..56d61a0
--- /dev/null
+++ b/lab2b.c
@@ -0,0 +1,15 @@
+#include "types.h"
+#include "user.h"
+int main (int argc, char **argv)
+{
+    int prir = set_prior(20);
+    printf(1, "PRIORITY: %d\n", prir);
+    int i,k;
+    for(i = 0; i < 43000; i++){
+        asm("nop");
+        for(k = 0; k < 43000; k++){
+            asm("nop");
+        }
+    }
+    exit();
+}
\ No newline at end of file
diff --git a/lab2c.c b/lab2c.c
new file mode 100644
index 0000000..f895181
--- /dev/null
+++ b/lab2c.c
@@ -0,0 +1,15 @@
+#include "types.h"
+#include "user.h"
+int main (int argc, char **argv)
+{
+    int prir = set_prior(30);
+    printf(1, "PRIORITY: %d\n", prir);
+    int i,k;
+    for(i = 0; i < 43000; i++){
+        asm("nop");
+        for(k = 0; k < 43000; k++){
+            asm("nop");
+        }
+    }
+    exit();
+}
\ No newline at end of file
diff --git a/proc.c b/proc.c
index 806b1b1..0f2b3eb 100644
--- a/proc.c
+++ b/proc.c
@@ -6,6 +6,7 @@
 #include "x86.h"
 #include "proc.h"
 #include "spinlock.h"
+#include "stddef.h"
 
 struct {
   struct spinlock lock;
@@ -88,6 +89,7 @@ allocproc(void)
 found:
   p->state = EMBRYO;
   p->pid = nextpid++;
+  p->prior_val = 0;
 
   release(&ptable.lock);
 
@@ -199,6 +201,7 @@ fork(void)
   np->sz = curproc->sz;
   np->parent = curproc;
   *np->tf = *curproc->tf;
+  np->prior_val = curproc->prior_val;
 
   // Clear %eax so that fork returns 0 in the child.
   np->tf->eax = 0;
@@ -233,6 +236,19 @@ exit(void)
 
   if(curproc == initproc)
     panic("init exiting");
+    
+  // Save finish time to current proccess.
+  acquire(&tickslock);
+  curproc->t_finish = ticks;
+  release(&tickslock);
+
+  cprintf("\nproc name: %s\n", curproc->name);
+  cprintf("Start time : %d\n", curproc->t_start);
+  cprintf("End time : %d\n", curproc->t_finish);
+  cprintf("Burst time : %d\n", curproc->burst_time);
+  cprintf("Burst tick : %d\n", curproc->burst_tick);
+  cprintf("Turnaround time : %d\n", curproc->t_finish - curproc->t_start);
+  cprintf("Waiting time : %d\n", (curproc->t_finish - curproc->t_start) - curproc->burst_time);
 
   // Close all open files.
   for(fd = 0; fd < NOFILE; fd++){
@@ -311,6 +327,20 @@ wait(void)
   }
 }
 
+// Rule 5: After some period of time S, move all the jobs in the system to the topmost queue. 
+void maximize_priorities(void){
+  struct proc *p;
+
+  acquire(&ptable.lock);
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+    if(p->state != RUNNABLE)
+      continue;
+
+    p->prior_val = 0; // Set to highest priority.
+  }
+  release(&ptable.lock);
+}
+
 //PAGEBREAK: 42
 // Per-CPU process scheduler.
 // Each CPU calls scheduler() after setting itself up.
@@ -324,18 +354,52 @@ scheduler(void)
 {
   struct proc *p;
   struct cpu *c = mycpu();
+  int aging_flag = 1; //set to 0 to test starvation.
   c->proc = 0;
+
+  uint start_time;
+  acquire(&tickslock);
+  start_time = ticks;
+  release(&tickslock);
+  uint current_time;
   
   for(;;){
+    acquire(&tickslock);
+    current_time = ticks;
+    release(&tickslock);
+
+    if(current_time - start_time < 4000 && current_time - start_time > 3997){
+      start_time = current_time;
+      maximize_priorities(); //comment out to test starvation.
+    }
+
     // Enable interrupts on this processor.
     sti();
 
-    // Loop over process table looking for process to run.
+    // Loop over process table looking for process with highest priority to run.
     acquire(&ptable.lock);
+    int prior_level = 31;
+
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+      if(p->state != RUNNABLE)
+        continue;
+
+      if(p->prior_val < prior_level) {
+          prior_level = p->prior_val;
+      }
+    }
+
+    // Rule 2: If Priority(A) = Priority(B), A & B run in round-robin fashion using the time slice (quantum length) of the given queue
     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
       if(p->state != RUNNABLE)
         continue;
 
+      if(p->prior_val > prior_level){
+        if(p->prior_val > 0 && aging_flag)
+          p->prior_val--; //increase priority for waiting
+        continue;
+      }
+
       // Switch to chosen process.  It is the process's job
       // to release ptable.lock and then reacquire it
       // before jumping back to us.
@@ -349,12 +413,33 @@ scheduler(void)
       // Process is done running for now.
       // It should have changed its p->state before coming back.
       c->proc = 0;
+
+      if(p->prior_val < 31 && aging_flag)
+        p->prior_val++;//decrease priority for running
+
+      acquire(&tickslock);
+      if(ticks > p->burst_tick){
+        p->burst_tick = ticks;
+        p->burst_time++;
+      }
+      release(&tickslock);
     }
+
     release(&ptable.lock);
 
   }
 }
 
+int
+set_prior(int prior_lvl)
+{
+    acquire(&ptable.lock);
+    myproc()->prior_val = prior_lvl;
+    release(&ptable.lock);
+    yield();
+    return myproc()->prior_val;
+}
+
 // Enter scheduler.  Must hold only ptable.lock
 // and have changed proc->state. Saves and restores
 // intena because intena is a property of this
@@ -531,4 +616,4 @@ procdump(void)
     }
     cprintf("\n");
   }
-}
+}
\ No newline at end of file
diff --git a/proc.h b/proc.h
index 1647114..156b37c 100644
--- a/proc.h
+++ b/proc.h
@@ -49,6 +49,11 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  int prior_val;
+  uint t_finish;
+  uint t_start;
+  int burst_tick;
+  uint burst_time;
 };
 
 // Process memory is laid out contiguously, low addresses first:
diff --git a/syscall.c b/syscall.c
index ee85261..87db278 100644
--- a/syscall.c
+++ b/syscall.c
@@ -101,6 +101,7 @@ extern int sys_sbrk(void);
 extern int sys_sleep(void);
 extern int sys_unlink(void);
 extern int sys_wait(void);
+extern int sys_set_prior(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
 
@@ -108,6 +109,7 @@ static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
 [SYS_exit]    sys_exit,
 [SYS_wait]    sys_wait,
+[SYS_set_prior] sys_set_prior,
 [SYS_pipe]    sys_pipe,
 [SYS_read]    sys_read,
 [SYS_kill]    sys_kill,
diff --git a/syscall.h b/syscall.h
index bc5f356..517f790 100644
--- a/syscall.h
+++ b/syscall.h
@@ -20,3 +20,4 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_set_prior  22
\ No newline at end of file
diff --git a/sysproc.c b/sysproc.c
index 0686d29..201b2c1 100644
--- a/sysproc.c
+++ b/sysproc.c
@@ -36,6 +36,19 @@ sys_kill(void)
   return kill(pid);
 }
 
+
+
+int
+sys_set_prior(void)
+{
+    int prior_val;
+
+    if( argint(0, &prior_val) < 0 )
+        return -1;
+
+    return set_prior(prior_val);
+}
+
 int
 sys_getpid(void)
 {
diff --git a/user.h b/user.h
index 4f99c52..045f902 100644
--- a/user.h
+++ b/user.h
@@ -6,6 +6,7 @@ int fork(void);
 int exit(void) __attribute__((noreturn));
 int wait(void);
 int pipe(int*);
+int set_prior(int);
 int write(int, const void*, int);
 int read(int, void*, int);
 int close(int);
diff --git a/usys.S b/usys.S
index 8bfd8a1..2706a59 100644
--- a/usys.S
+++ b/usys.S
@@ -11,6 +11,7 @@
 SYSCALL(fork)
 SYSCALL(exit)
 SYSCALL(wait)
+SYSCALL(set_prior)
 SYSCALL(pipe)
 SYSCALL(read)
 SYSCALL(write)
@@ -28,4 +29,4 @@ SYSCALL(dup)
 SYSCALL(getpid)
 SYSCALL(sbrk)
 SYSCALL(sleep)
-SYSCALL(uptime)
+SYSCALL(uptime)
\ No newline at end of file
